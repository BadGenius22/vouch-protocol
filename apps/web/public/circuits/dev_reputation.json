{
  "noir_version": "1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9",
  "hash": "15437050437515972018",
  "abi": {
    "parameters": [
      {
        "name": "wallet_pubkey",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "secret",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "program_count",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "private"
      },
      {
        "name": "tvl_amounts",
        "type": {
          "kind": "array",
          "length": 5,
          "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
        },
        "visibility": "private"
      },
      {
        "name": "min_tvl",
        "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
        "visibility": "public"
      },
      {
        "name": "commitment",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "nullifier",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "14990209321349310352": { "error_kind": "string", "string": "attempt to add with overflow" }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pZbRjqowFEX/pc889LQ9pfVXbm4MKk5ICBoGbnJj/Pdp8WzGeWBi6tNeUPcK4Kl4U6f2MH/su+F8+VS7Pzd1GLu+7z72/eXYTN1lSGdv90rhcD+NbZtOqaf11Lo2YztMajfMfV+pf00/Lx/6vDbDklMzplVdqXY4pUzCc9e3me7Vd1tvV+vopRzIrHWmV/vBEfqsS/rGoG9DST8G6Ufign40a9/TVp+3+0ZTFIHRxn8bXhdYvQqeH8Grd0Ca8BWStq7gGZB2YTX48K4hFF2DMRgkMpaLDDq+a1iHiSwVPYc6WhgCxRJDqNdriLroLmLgdaDIbxny0Lw31L8bNqf6bzpojt3445dQkWW1c1VKv2wXsrVkkIyPdFqSJI2klXSSLCk+Jz4nPic+Fh+Lj8XH4mPxsfhYfCw+Fh+Lz4vPi8+Lz4vPi8+Lz4vPi88nX8gZH1nrvKcyEMAALMDl4c3AAA+oAQEQBYIGECCbbQYLcAAGZHO+0FA/RoBCAESBqAEEMAALcAAGeADMEeYoZqM1gAAGYAEOwAAPqAEBADPBTDATzAQzwUwwE8wEMy3me94aY9cc+lZe9Od5OD6996f/V6zgn8F1vBzb0zy2eWcsa2mvfAE=",
  "file_map": {
    "51": {
      "source": "// Vouch Protocol - Developer Reputation Circuit\n// Proves: \"I control a wallet that deployed programs with >= min_tvl TVL\"\n// Without revealing: which wallet, which programs, exact TVL\n\nuse std::hash::blake2s;\n\n// Maximum number of programs to prove\nglobal MAX_PROGRAMS: u32 = 5;\n\nfn main(\n    // Private inputs (hidden from verifier)\n    wallet_pubkey: [u8; 32],\n    secret: [u8; 32],\n    program_count: u8,\n    tvl_amounts: [u64; MAX_PROGRAMS],\n\n    // Public inputs (visible to verifier)\n    min_tvl: pub u64,\n    commitment: pub [u8; 32],\n    nullifier: pub [u8; 32]\n) {\n    // 1. Verify commitment = hash(wallet_pubkey || secret)\n    // This proves the prover knows the wallet that created the commitment\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let computed_commitment: [u8; 32] = blake2s(preimage);\n    assert(computed_commitment == commitment);\n\n    // 2. Verify program count is valid\n    assert(program_count >= 1);\n    assert(program_count as u32 <= MAX_PROGRAMS);\n\n    // 3. Sum TVL across all programs\n    let mut total_tvl: u64 = 0;\n    for i in 0..MAX_PROGRAMS {\n        total_tvl = total_tvl + tvl_amounts[i];\n    }\n\n    // 4. Verify total TVL meets threshold\n    assert(total_tvl >= min_tvl);\n\n    // 5. Verify nullifier is derived correctly\n    // nullifier = hash(wallet_pubkey || domain_separator)\n    // Domain separator: \"vouch_dev\" padded to 32 bytes\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    // Domain separator: \"vouch_dev\" in ASCII (9 bytes, rest padded with zeros)\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let computed_nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Direct array comparison (more efficient than byte-by-byte)\n    assert(computed_nullifier == nullifier);\n}\n\n#[test]\nfn test_valid_proof() {\n    let wallet_pubkey: [u8; 32] = [1; 32];\n    let secret: [u8; 32] = [2; 32];\n\n    // Compute commitment\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    // Compute nullifier\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // TVL: 50K + 40K + 30K = 120K (meets 100K threshold)\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [50000, 40000, 30000, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        3,\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_threshold_exact_match() {\n    let wallet_pubkey: [u8; 32] = [3; 32];\n    let secret: [u8; 32] = [4; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Exactly 100K TVL (meets 100K threshold)\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n// === Negative Tests ===\n\n#[test(should_fail)]\nfn test_below_threshold_fails() {\n    let wallet_pubkey: [u8; 32] = [5; 32];\n    let secret: [u8; 32] = [6; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Only 50K TVL (below 100K threshold) - should fail\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [30000, 20000, 0, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_commitment_fails() {\n    let wallet_pubkey: [u8; 32] = [7; 32];\n    let secret: [u8; 32] = [8; 32];\n\n    // Compute correct nullifier\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Use WRONG commitment (all zeros instead of computed)\n    let wrong_commitment: [u8; 32] = [0; 32];\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 50000, 0, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        100000,\n        wrong_commitment,  // Wrong commitment - should fail\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_nullifier_fails() {\n    let wallet_pubkey: [u8; 32] = [9; 32];\n    let secret: [u8; 32] = [10; 32];\n\n    // Compute correct commitment\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    // Use WRONG nullifier (all zeros instead of computed)\n    let wrong_nullifier: [u8; 32] = [0; 32];\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 50000, 0, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        100000,\n        commitment,\n        wrong_nullifier  // Wrong nullifier - should fail\n    );\n}\n\n#[test(should_fail)]\nfn test_zero_programs_fails() {\n    let wallet_pubkey: [u8; 32] = [11; 32];\n    let secret: [u8; 32] = [12; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [0, 0, 0, 0, 0];\n\n    // Zero programs - should fail (program_count must be >= 1)\n    main(\n        wallet_pubkey,\n        secret,\n        0,  // Zero programs - should fail\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n// === Additional Edge Case Tests ===\n\n#[test]\nfn test_single_program_meets_threshold() {\n    let wallet_pubkey: [u8; 32] = [13; 32];\n    let secret: [u8; 32] = [14; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Single program with 200K TVL\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [200000, 0, 0, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        100000,  // 100K threshold\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_max_programs() {\n    let wallet_pubkey: [u8; 32] = [15; 32];\n    let secret: [u8; 32] = [16; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // All 5 programs with TVL (20K each = 100K total)\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [20000, 20000, 20000, 20000, 20000];\n\n    main(\n        wallet_pubkey,\n        secret,\n        5,  // MAX_PROGRAMS\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_zero_threshold() {\n    let wallet_pubkey: [u8; 32] = [17; 32];\n    let secret: [u8; 32] = [18; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Even with 0 TVL, 0 threshold should pass\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [0, 0, 0, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        0,  // Zero threshold\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_exceed_max_programs_fails() {\n    let wallet_pubkey: [u8; 32] = [19; 32];\n    let secret: [u8; 32] = [20; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n\n    // program_count = 6 exceeds MAX_PROGRAMS (5) - should fail\n    main(\n        wallet_pubkey,\n        secret,\n        6,\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_large_tvl_values() {\n    let wallet_pubkey: [u8; 32] = [21; 32];\n    let secret: [u8; 32] = [22; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Large TVL values (billions in lamports)\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [1000000000000, 500000000000, 0, 0, 0];\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        1000000000000,  // 1 trillion threshold\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_secret_fails() {\n    let wallet_pubkey: [u8; 32] = [23; 32];\n    let secret: [u8; 32] = [24; 32];\n    let wrong_secret: [u8; 32] = [25; 32];  // Different secret\n\n    // Compute commitment with CORRECT secret\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n\n    // Use WRONG secret - should fail commitment verification\n    main(\n        wallet_pubkey,\n        wrong_secret,  // Wrong secret\n        1,\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_wallet_fails() {\n    let wallet_pubkey: [u8; 32] = [26; 32];\n    let wrong_wallet: [u8; 32] = [27; 32];  // Different wallet\n    let secret: [u8; 32] = [28; 32];\n\n    // Compute commitment with CORRECT wallet\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    // Compute nullifier with CORRECT wallet\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118];\n    for i in 0..9 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n\n    // Use WRONG wallet - should fail\n    main(\n        wrong_wallet,  // Wrong wallet\n        secret,\n        1,\n        tvl_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n",
      "path": "/Users/dewaxindo/Documents/Work/vouch-protocol/circuits/dev_reputation/src/main.nr"
    }
  },
  "expression_width": { "Bounded": { "width": 4 } }
}
