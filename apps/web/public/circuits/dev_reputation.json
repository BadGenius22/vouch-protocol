{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"11984505072644891535","abi":{"parameters":[{"name":"wallet_pubkey","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"secret","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"program_count","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"tvl_amounts","type":{"kind":"array","length":5,"type":{"kind":"integer","sign":"unsigned","width":64}},"visibility":"private"},{"name":"min_tvl","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"epoch","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"data_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"nullifier","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"return_type":null,"error_types":{"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"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","file_map":{"51":{"source":"// Vouch Protocol - Shared Circuit Library\n// Common cryptographic functions used across all circuits\n\nuse std::hash::blake2s;\n\n/// Compute commitment = blake2s(wallet_pubkey || secret)\n/// This proves the prover knows the wallet that created the commitment\npub fn compute_commitment(wallet_pubkey: [u8; 32], secret: [u8; 32]) -> [u8; 32] {\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    blake2s(preimage)\n}\n\n/// Compute nullifier with temporal binding\n/// nullifier = blake2s(wallet_pubkey || domain || epoch_bytes)\n///\n/// The epoch adds temporal binding to prevent replay attacks:\n/// - Same wallet + same domain + different epoch = different nullifier\n/// - Epoch can represent: day number, week number, campaign ID, etc.\n///\n/// Layout: [wallet_pubkey (32 bytes)] [domain (up to 24 bytes)] [epoch (8 bytes)]\npub fn compute_nullifier_with_epoch<let DOMAIN_LEN: u32>(\n    wallet_pubkey: [u8; 32],\n    domain: [u8; DOMAIN_LEN],\n    epoch: u64\n) -> [u8; 32] {\n    // Use 72-byte preimage: 32 (wallet) + 32 (domain padded) + 8 (epoch)\n    let mut preimage: [u8; 72] = [0; 72];\n\n    // Copy wallet pubkey\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n    }\n\n    // Copy domain (padded to 32 bytes)\n    for i in 0..DOMAIN_LEN {\n        preimage[32 + i] = domain[i];\n    }\n\n    // Append epoch as big-endian bytes\n    let epoch_bytes = epoch_to_bytes(epoch);\n    for i in 0..8 {\n        preimage[64 + i] = epoch_bytes[i];\n    }\n\n    blake2s(preimage)\n}\n\n/// Legacy nullifier computation (without epoch) - for backwards compatibility\n/// nullifier = blake2s(wallet_pubkey || domain_padded_to_32)\npub fn compute_nullifier_legacy<let DOMAIN_LEN: u32>(\n    wallet_pubkey: [u8; 32],\n    domain: [u8; DOMAIN_LEN]\n) -> [u8; 32] {\n    let mut preimage: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n    }\n\n    for i in 0..DOMAIN_LEN {\n        preimage[32 + i] = domain[i];\n    }\n\n    blake2s(preimage)\n}\n\n/// Compute data hash for private data integrity\n/// This ensures the prover commits to specific private data values\npub fn compute_data_hash(data: [u8; 64]) -> [u8; 32] {\n    blake2s(data)\n}\n\n/// Convert u64 array to bytes for hashing (for TVL/trade amounts)\n/// Takes up to 8 u64 values and converts to 64-byte array\npub fn amounts_to_bytes_8(amounts: [u64; 8]) -> [u8; 64] {\n    let mut result: [u8; 64] = [0; 64];\n    for i in 0..8 {\n        let bytes = u64_to_bytes(amounts[i]);\n        for j in 0..8 {\n            result[i * 8 + j] = bytes[j];\n        }\n    }\n    result\n}\n\n/// Convert epoch (u64) to big-endian bytes\npub fn epoch_to_bytes(epoch: u64) -> [u8; 8] {\n    u64_to_bytes(epoch)\n}\n\n/// Convert u64 to big-endian bytes\nfn u64_to_bytes(value: u64) -> [u8; 8] {\n    let mut bytes: [u8; 8] = [0; 8];\n    bytes[0] = ((value >> 56) & 0xff) as u8;\n    bytes[1] = ((value >> 48) & 0xff) as u8;\n    bytes[2] = ((value >> 40) & 0xff) as u8;\n    bytes[3] = ((value >> 32) & 0xff) as u8;\n    bytes[4] = ((value >> 24) & 0xff) as u8;\n    bytes[5] = ((value >> 16) & 0xff) as u8;\n    bytes[6] = ((value >> 8) & 0xff) as u8;\n    bytes[7] = (value & 0xff) as u8;\n    bytes\n}\n\n// ============================================================================\n// Domain Separators\n// ============================================================================\n\n/// Domain separator for developer reputation circuit\npub global DOMAIN_DEV: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118]; // \"vouch_dev\"\n\n/// Domain separator for whale trading circuit\npub global DOMAIN_WHALE: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101]; // \"vouch_whale\"\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[test]\nfn test_commitment_computation() {\n    let wallet: [u8; 32] = [1; 32];\n    let secret: [u8; 32] = [2; 32];\n\n    let commitment = compute_commitment(wallet, secret);\n\n    // Verify deterministic output\n    let commitment2 = compute_commitment(wallet, secret);\n    assert(commitment == commitment2);\n\n    // Different input = different output\n    let different_secret: [u8; 32] = [3; 32];\n    let commitment3 = compute_commitment(wallet, different_secret);\n    assert(commitment != commitment3);\n}\n\n#[test]\nfn test_nullifier_with_epoch() {\n    let wallet: [u8; 32] = [1; 32];\n    let domain: [u8; 9] = DOMAIN_DEV;\n\n    let nullifier_epoch1 = compute_nullifier_with_epoch(wallet, domain, 1);\n    let nullifier_epoch2 = compute_nullifier_with_epoch(wallet, domain, 2);\n\n    // Different epochs = different nullifiers\n    assert(nullifier_epoch1 != nullifier_epoch2);\n\n    // Same epoch = same nullifier\n    let nullifier_epoch1_again = compute_nullifier_with_epoch(wallet, domain, 1);\n    assert(nullifier_epoch1 == nullifier_epoch1_again);\n}\n\n#[test]\nfn test_domain_separation() {\n    let wallet: [u8; 32] = [1; 32];\n\n    let nullifier_dev = compute_nullifier_with_epoch(wallet, DOMAIN_DEV, 1);\n    let nullifier_whale = compute_nullifier_with_epoch(wallet, DOMAIN_WHALE, 1);\n\n    // Different domains = different nullifiers (even same wallet, same epoch)\n    assert(nullifier_dev != nullifier_whale);\n}\n\n#[test]\nfn test_u64_to_bytes() {\n    // Test with known value: 0x0102030405060708\n    let value: u64 = 0x0102030405060708;\n    let bytes = u64_to_bytes(value);\n\n    assert(bytes[0] == 1);\n    assert(bytes[1] == 2);\n    assert(bytes[2] == 3);\n    assert(bytes[3] == 4);\n    assert(bytes[4] == 5);\n    assert(bytes[5] == 6);\n    assert(bytes[6] == 7);\n    assert(bytes[7] == 8);\n}\n\n#[test]\nfn test_amounts_to_bytes() {\n    let amounts: [u64; 8] = [100, 200, 0, 0, 0, 0, 0, 0];\n    let bytes = amounts_to_bytes_8(amounts);\n\n    // First amount (100 = 0x64) should be at bytes 0-7\n    assert(bytes[7] == 100); // Last byte of first u64\n\n    // Second amount (200 = 0xC8) should be at bytes 8-15\n    assert(bytes[15] == 200); // Last byte of second u64\n}\n","path":"/home/dewaxindo/Solana/vouch-protocol/circuits/vouch_lib/src/lib.nr"},"52":{"source":"// Vouch Protocol - Developer Reputation Circuit (v2)\n// Proves: \"I control a wallet that deployed programs with >= min_tvl TVL\"\n// Without revealing: which wallet, which programs, exact TVL\n//\n// Security features:\n// - epoch: Temporal binding prevents replay attacks (nullifiers are time-bound)\n// - data_hash: Commits to private data integrity (verifier can check data freshness)\n\nuse vouch_lib::{\n    compute_commitment,\n    compute_nullifier_with_epoch,\n    amounts_to_bytes_8,\n    compute_data_hash,\n    DOMAIN_DEV\n};\n\n// Maximum number of programs to prove\nglobal MAX_PROGRAMS: u32 = 5;\n\nfn main(\n    // Private inputs (hidden from verifier)\n    wallet_pubkey: [u8; 32],\n    secret: [u8; 32],\n    program_count: u8,\n    tvl_amounts: [u64; MAX_PROGRAMS],\n\n    // Public inputs (visible to verifier)\n    min_tvl: pub u64,\n    epoch: pub u64,           // Temporal binding (e.g., day number, campaign ID)\n    data_hash: pub [u8; 32],  // Hash of private TVL data for integrity\n    commitment: pub [u8; 32],\n    nullifier: pub [u8; 32]\n) {\n    // 1. Verify commitment = hash(wallet_pubkey || secret)\n    let computed_commitment = compute_commitment(wallet_pubkey, secret);\n    assert(computed_commitment == commitment);\n\n    // 2. Verify program count is valid\n    assert(program_count >= 1);\n    assert(program_count as u32 <= MAX_PROGRAMS);\n\n    // 3. Sum TVL across all programs\n    let mut total_tvl: u64 = 0;\n    for i in 0..MAX_PROGRAMS {\n        total_tvl = total_tvl + tvl_amounts[i];\n    }\n\n    // 4. Verify total TVL meets threshold\n    assert(total_tvl >= min_tvl);\n\n    // 5. Verify data hash matches private data\n    // This ensures the prover can't lie about TVL amounts\n    let mut tvl_for_hash: [u64; 8] = [0; 8];\n    for i in 0..MAX_PROGRAMS {\n        tvl_for_hash[i] = tvl_amounts[i];\n    }\n    let data_bytes = amounts_to_bytes_8(tvl_for_hash);\n    let computed_data_hash = compute_data_hash(data_bytes);\n    assert(computed_data_hash == data_hash);\n\n    // 6. Verify nullifier with temporal binding\n    // nullifier = hash(wallet_pubkey || domain || epoch)\n    let computed_nullifier = compute_nullifier_with_epoch(wallet_pubkey, DOMAIN_DEV, epoch);\n    assert(computed_nullifier == nullifier);\n}\n\n// ============================================================================\n// Helper for tests\n// ============================================================================\n\nfn compute_test_nullifier(wallet_pubkey: [u8; 32], epoch: u64) -> [u8; 32] {\n    compute_nullifier_with_epoch(wallet_pubkey, DOMAIN_DEV, epoch)\n}\n\nfn compute_test_data_hash(tvl_amounts: [u64; MAX_PROGRAMS]) -> [u8; 32] {\n    let mut tvl_for_hash: [u64; 8] = [0; 8];\n    for i in 0..MAX_PROGRAMS {\n        tvl_for_hash[i] = tvl_amounts[i];\n    }\n    let data_bytes = amounts_to_bytes_8(tvl_for_hash);\n    compute_data_hash(data_bytes)\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[test]\nfn test_valid_proof() {\n    let wallet_pubkey: [u8; 32] = [1; 32];\n    let secret: [u8; 32] = [2; 32];\n    let epoch: u64 = 20260120; // Example: YYYYMMDD format\n\n    // Compute commitment\n    let commitment = compute_commitment(wallet_pubkey, secret);\n\n    // Compute nullifier with epoch\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // TVL: 50K + 40K + 30K = 120K (meets 100K threshold)\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [50000, 40000, 30000, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        3,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_threshold_exact_match() {\n    let wallet_pubkey: [u8; 32] = [3; 32];\n    let secret: [u8; 32] = [4; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Exactly 100K TVL\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_different_epochs_different_nullifiers() {\n    let wallet_pubkey: [u8; 32] = [5; 32];\n\n    let nullifier_epoch1 = compute_test_nullifier(wallet_pubkey, 1);\n    let nullifier_epoch2 = compute_test_nullifier(wallet_pubkey, 2);\n\n    // Critical security property: different epochs = different nullifiers\n    assert(nullifier_epoch1 != nullifier_epoch2);\n}\n\n// === Negative Tests ===\n\n#[test(should_fail)]\nfn test_below_threshold_fails() {\n    let wallet_pubkey: [u8; 32] = [5; 32];\n    let secret: [u8; 32] = [6; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Only 50K TVL (below 100K threshold)\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [30000, 20000, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_commitment_fails() {\n    let wallet_pubkey: [u8; 32] = [7; 32];\n    let secret: [u8; 32] = [8; 32];\n    let epoch: u64 = 1;\n\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Use WRONG commitment\n    let wrong_commitment: [u8; 32] = [0; 32];\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 50000, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        wrong_commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_nullifier_fails() {\n    let wallet_pubkey: [u8; 32] = [9; 32];\n    let secret: [u8; 32] = [10; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n\n    // Use WRONG nullifier\n    let wrong_nullifier: [u8; 32] = [0; 32];\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 50000, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        wrong_nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_epoch_nullifier_fails() {\n    let wallet_pubkey: [u8; 32] = [11; 32];\n    let secret: [u8; 32] = [12; 32];\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n\n    // Compute nullifier with epoch 1\n    let nullifier = compute_test_nullifier(wallet_pubkey, 1);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    // But use epoch 2 in the proof - should fail\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        100000,\n        2,  // Different epoch\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_data_hash_fails() {\n    let wallet_pubkey: [u8; 32] = [13; 32];\n    let secret: [u8; 32] = [14; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Actual TVL amounts\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n\n    // Compute hash from DIFFERENT amounts\n    let fake_amounts: [u64; MAX_PROGRAMS] = [200000, 0, 0, 0, 0];\n    let wrong_data_hash = compute_test_data_hash(fake_amounts);\n\n    // Should fail - data hash doesn't match actual TVL\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        100000,\n        epoch,\n        wrong_data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_zero_programs_fails() {\n    let wallet_pubkey: [u8; 32] = [15; 32];\n    let secret: [u8; 32] = [16; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [0, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        0,  // Zero programs - should fail\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n// === Additional Edge Case Tests ===\n\n#[test]\nfn test_single_program_meets_threshold() {\n    let wallet_pubkey: [u8; 32] = [17; 32];\n    let secret: [u8; 32] = [18; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [200000, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_max_programs() {\n    let wallet_pubkey: [u8; 32] = [19; 32];\n    let secret: [u8; 32] = [20; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // All 5 programs with TVL\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [20000, 20000, 20000, 20000, 20000];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        5,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_zero_threshold() {\n    let wallet_pubkey: [u8; 32] = [21; 32];\n    let secret: [u8; 32] = [22; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [0, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        tvl_amounts,\n        0,  // Zero threshold\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_exceed_max_programs_fails() {\n    let wallet_pubkey: [u8; 32] = [23; 32];\n    let secret: [u8; 32] = [24; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        6,  // Exceeds MAX_PROGRAMS\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_large_tvl_values() {\n    let wallet_pubkey: [u8; 32] = [25; 32];\n    let secret: [u8; 32] = [26; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Large TVL values (billions)\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [1000000000000, 500000000000, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        tvl_amounts,\n        1000000000000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_secret_fails() {\n    let wallet_pubkey: [u8; 32] = [27; 32];\n    let secret: [u8; 32] = [28; 32];\n    let wrong_secret: [u8; 32] = [29; 32];\n    let epoch: u64 = 1;\n\n    // Compute commitment with CORRECT secret\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    // Use WRONG secret - should fail\n    main(\n        wallet_pubkey,\n        wrong_secret,\n        1,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_wallet_fails() {\n    let wallet_pubkey: [u8; 32] = [30; 32];\n    let wrong_wallet: [u8; 32] = [31; 32];\n    let secret: [u8; 32] = [32; 32];\n    let epoch: u64 = 1;\n\n    // Compute with CORRECT wallet\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let tvl_amounts: [u64; MAX_PROGRAMS] = [100000, 0, 0, 0, 0];\n    let data_hash = compute_test_data_hash(tvl_amounts);\n\n    // Use WRONG wallet - should fail\n    main(\n        wrong_wallet,\n        secret,\n        1,\n        tvl_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n","path":"/home/dewaxindo/Solana/vouch-protocol/circuits/dev_reputation/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}