{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"13368461198567685190","abi":{"parameters":[{"name":"wallet_pubkey","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"secret","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"trade_count","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"trade_amounts","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":64}},"visibility":"private"},{"name":"min_volume","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"epoch","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"data_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"nullifier","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"return_type":null,"error_types":{"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"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","file_map":{"51":{"source":"// Vouch Protocol - Shared Circuit Library\n// Common cryptographic functions used across all circuits\n\nuse std::hash::blake2s;\n\n/// Compute commitment = blake2s(wallet_pubkey || secret)\n/// This proves the prover knows the wallet that created the commitment\npub fn compute_commitment(wallet_pubkey: [u8; 32], secret: [u8; 32]) -> [u8; 32] {\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    blake2s(preimage)\n}\n\n/// Compute nullifier with temporal binding\n/// nullifier = blake2s(wallet_pubkey || domain || epoch_bytes)\n///\n/// The epoch adds temporal binding to prevent replay attacks:\n/// - Same wallet + same domain + different epoch = different nullifier\n/// - Epoch can represent: day number, week number, campaign ID, etc.\n///\n/// Layout: [wallet_pubkey (32 bytes)] [domain (up to 24 bytes)] [epoch (8 bytes)]\npub fn compute_nullifier_with_epoch<let DOMAIN_LEN: u32>(\n    wallet_pubkey: [u8; 32],\n    domain: [u8; DOMAIN_LEN],\n    epoch: u64\n) -> [u8; 32] {\n    // Use 72-byte preimage: 32 (wallet) + 32 (domain padded) + 8 (epoch)\n    let mut preimage: [u8; 72] = [0; 72];\n\n    // Copy wallet pubkey\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n    }\n\n    // Copy domain (padded to 32 bytes)\n    for i in 0..DOMAIN_LEN {\n        preimage[32 + i] = domain[i];\n    }\n\n    // Append epoch as big-endian bytes\n    let epoch_bytes = epoch_to_bytes(epoch);\n    for i in 0..8 {\n        preimage[64 + i] = epoch_bytes[i];\n    }\n\n    blake2s(preimage)\n}\n\n/// Legacy nullifier computation (without epoch) - for backwards compatibility\n/// nullifier = blake2s(wallet_pubkey || domain_padded_to_32)\npub fn compute_nullifier_legacy<let DOMAIN_LEN: u32>(\n    wallet_pubkey: [u8; 32],\n    domain: [u8; DOMAIN_LEN]\n) -> [u8; 32] {\n    let mut preimage: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n    }\n\n    for i in 0..DOMAIN_LEN {\n        preimage[32 + i] = domain[i];\n    }\n\n    blake2s(preimage)\n}\n\n/// Compute data hash for private data integrity\n/// This ensures the prover commits to specific private data values\npub fn compute_data_hash(data: [u8; 64]) -> [u8; 32] {\n    blake2s(data)\n}\n\n/// Convert u64 array to bytes for hashing (for TVL/trade amounts)\n/// Takes up to 8 u64 values and converts to 64-byte array\npub fn amounts_to_bytes_8(amounts: [u64; 8]) -> [u8; 64] {\n    let mut result: [u8; 64] = [0; 64];\n    for i in 0..8 {\n        let bytes = u64_to_bytes(amounts[i]);\n        for j in 0..8 {\n            result[i * 8 + j] = bytes[j];\n        }\n    }\n    result\n}\n\n/// Convert epoch (u64) to big-endian bytes\npub fn epoch_to_bytes(epoch: u64) -> [u8; 8] {\n    u64_to_bytes(epoch)\n}\n\n/// Convert u64 to big-endian bytes\nfn u64_to_bytes(value: u64) -> [u8; 8] {\n    let mut bytes: [u8; 8] = [0; 8];\n    bytes[0] = ((value >> 56) & 0xff) as u8;\n    bytes[1] = ((value >> 48) & 0xff) as u8;\n    bytes[2] = ((value >> 40) & 0xff) as u8;\n    bytes[3] = ((value >> 32) & 0xff) as u8;\n    bytes[4] = ((value >> 24) & 0xff) as u8;\n    bytes[5] = ((value >> 16) & 0xff) as u8;\n    bytes[6] = ((value >> 8) & 0xff) as u8;\n    bytes[7] = (value & 0xff) as u8;\n    bytes\n}\n\n// ============================================================================\n// Domain Separators\n// ============================================================================\n\n/// Domain separator for developer reputation circuit\npub global DOMAIN_DEV: [u8; 9] = [118, 111, 117, 99, 104, 95, 100, 101, 118]; // \"vouch_dev\"\n\n/// Domain separator for whale trading circuit\npub global DOMAIN_WHALE: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101]; // \"vouch_whale\"\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[test]\nfn test_commitment_computation() {\n    let wallet: [u8; 32] = [1; 32];\n    let secret: [u8; 32] = [2; 32];\n\n    let commitment = compute_commitment(wallet, secret);\n\n    // Verify deterministic output\n    let commitment2 = compute_commitment(wallet, secret);\n    assert(commitment == commitment2);\n\n    // Different input = different output\n    let different_secret: [u8; 32] = [3; 32];\n    let commitment3 = compute_commitment(wallet, different_secret);\n    assert(commitment != commitment3);\n}\n\n#[test]\nfn test_nullifier_with_epoch() {\n    let wallet: [u8; 32] = [1; 32];\n    let domain: [u8; 9] = DOMAIN_DEV;\n\n    let nullifier_epoch1 = compute_nullifier_with_epoch(wallet, domain, 1);\n    let nullifier_epoch2 = compute_nullifier_with_epoch(wallet, domain, 2);\n\n    // Different epochs = different nullifiers\n    assert(nullifier_epoch1 != nullifier_epoch2);\n\n    // Same epoch = same nullifier\n    let nullifier_epoch1_again = compute_nullifier_with_epoch(wallet, domain, 1);\n    assert(nullifier_epoch1 == nullifier_epoch1_again);\n}\n\n#[test]\nfn test_domain_separation() {\n    let wallet: [u8; 32] = [1; 32];\n\n    let nullifier_dev = compute_nullifier_with_epoch(wallet, DOMAIN_DEV, 1);\n    let nullifier_whale = compute_nullifier_with_epoch(wallet, DOMAIN_WHALE, 1);\n\n    // Different domains = different nullifiers (even same wallet, same epoch)\n    assert(nullifier_dev != nullifier_whale);\n}\n\n#[test]\nfn test_u64_to_bytes() {\n    // Test with known value: 0x0102030405060708\n    let value: u64 = 0x0102030405060708;\n    let bytes = u64_to_bytes(value);\n\n    assert(bytes[0] == 1);\n    assert(bytes[1] == 2);\n    assert(bytes[2] == 3);\n    assert(bytes[3] == 4);\n    assert(bytes[4] == 5);\n    assert(bytes[5] == 6);\n    assert(bytes[6] == 7);\n    assert(bytes[7] == 8);\n}\n\n#[test]\nfn test_amounts_to_bytes() {\n    let amounts: [u64; 8] = [100, 200, 0, 0, 0, 0, 0, 0];\n    let bytes = amounts_to_bytes_8(amounts);\n\n    // First amount (100 = 0x64) should be at bytes 0-7\n    assert(bytes[7] == 100); // Last byte of first u64\n\n    // Second amount (200 = 0xC8) should be at bytes 8-15\n    assert(bytes[15] == 200); // Last byte of second u64\n}\n","path":"/home/dewaxindo/Solana/vouch-protocol/circuits/vouch_lib/src/lib.nr"},"53":{"source":"// Vouch Protocol - Whale Trading Circuit (v2)\n// Proves: \"I control a wallet that traded >= min_volume in the period\"\n// Without revealing: which wallet, which trades, exact volume\n//\n// Security features:\n// - epoch: Temporal binding prevents replay attacks (nullifiers are time-bound)\n// - data_hash: Commits to private data integrity (verifier can check data freshness)\n\nuse std::hash::blake2s;\nuse vouch_lib::{\n    compute_commitment,\n    compute_nullifier_with_epoch,\n    DOMAIN_WHALE\n};\n\n// Maximum number of trades to prove\nglobal MAX_TRADES: u32 = 20;\n\nfn main(\n    // Private inputs (hidden from verifier)\n    wallet_pubkey: [u8; 32],\n    secret: [u8; 32],\n    trade_count: u8,\n    trade_amounts: [u64; MAX_TRADES],\n\n    // Public inputs (visible to verifier)\n    min_volume: pub u64,\n    epoch: pub u64,           // Temporal binding (e.g., day number, campaign ID)\n    data_hash: pub [u8; 32],  // Hash of private trade data for integrity\n    commitment: pub [u8; 32],\n    nullifier: pub [u8; 32]\n) {\n    // 1. Verify commitment = hash(wallet_pubkey || secret)\n    let computed_commitment = compute_commitment(wallet_pubkey, secret);\n    assert(computed_commitment == commitment);\n\n    // 2. Verify trade count is valid\n    assert(trade_count >= 1);\n    assert(trade_count as u32 <= MAX_TRADES);\n\n    // 3. Sum trading volume\n    let mut total_volume: u64 = 0;\n    for i in 0..MAX_TRADES {\n        total_volume = total_volume + trade_amounts[i];\n    }\n\n    // 4. Verify total volume meets threshold\n    assert(total_volume >= min_volume);\n\n    // 5. Verify data hash matches private data\n    // This ensures the prover can't lie about trade amounts\n    // Hash trades in chunks of 8 (using 160 bytes = 20 trades * 8 bytes)\n    let computed_data_hash = compute_trade_data_hash(trade_amounts);\n    assert(computed_data_hash == data_hash);\n\n    // 6. Verify nullifier with temporal binding\n    // nullifier = hash(wallet_pubkey || domain || epoch)\n    let computed_nullifier = compute_nullifier_with_epoch(wallet_pubkey, DOMAIN_WHALE, epoch);\n    assert(computed_nullifier == nullifier);\n}\n\n// ============================================================================\n// Helper functions\n// ============================================================================\n\n/// Compute hash of trade data (20 u64 values = 160 bytes)\n/// We hash in two rounds to avoid large preimage sizes\nfn compute_trade_data_hash(trade_amounts: [u64; MAX_TRADES]) -> [u8; 32] {\n    // First: hash first 10 trades\n    let mut first_half: [u8; 80] = [0; 80];\n    for i in 0..10 {\n        let bytes = u64_to_bytes(trade_amounts[i]);\n        for j in 0..8 {\n            first_half[i * 8 + j] = bytes[j];\n        }\n    }\n\n    // Second: hash second 10 trades\n    let mut second_half: [u8; 80] = [0; 80];\n    for i in 0..10 {\n        let bytes = u64_to_bytes(trade_amounts[10 + i]);\n        for j in 0..8 {\n            second_half[i * 8 + j] = bytes[j];\n        }\n    }\n\n    // Combine hashes\n    let hash1: [u8; 32] = blake2s(first_half);\n    let hash2: [u8; 32] = blake2s(second_half);\n\n    // Final hash = blake2s(hash1 || hash2)\n    let mut combined: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        combined[i] = hash1[i];\n        combined[32 + i] = hash2[i];\n    }\n    blake2s(combined)\n}\n\n/// Convert u64 to big-endian bytes\nfn u64_to_bytes(value: u64) -> [u8; 8] {\n    let mut bytes: [u8; 8] = [0; 8];\n    bytes[0] = ((value >> 56) & 0xff) as u8;\n    bytes[1] = ((value >> 48) & 0xff) as u8;\n    bytes[2] = ((value >> 40) & 0xff) as u8;\n    bytes[3] = ((value >> 32) & 0xff) as u8;\n    bytes[4] = ((value >> 24) & 0xff) as u8;\n    bytes[5] = ((value >> 16) & 0xff) as u8;\n    bytes[6] = ((value >> 8) & 0xff) as u8;\n    bytes[7] = (value & 0xff) as u8;\n    bytes\n}\n\n// ============================================================================\n// Test helpers\n// ============================================================================\n\nfn compute_test_nullifier(wallet_pubkey: [u8; 32], epoch: u64) -> [u8; 32] {\n    compute_nullifier_with_epoch(wallet_pubkey, DOMAIN_WHALE, epoch)\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[test]\nfn test_valid_whale_proof() {\n    let wallet_pubkey: [u8; 32] = [1; 32];\n    let secret: [u8; 32] = [2; 32];\n    let epoch: u64 = 20260120;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Volume: 10K + 15K + 20K + 5K + 25K = 75K (meets 50K threshold)\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 10000;\n    trade_amounts[1] = 15000;\n    trade_amounts[2] = 20000;\n    trade_amounts[3] = 5000;\n    trade_amounts[4] = 25000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        5,\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_high_volume_whale() {\n    let wallet_pubkey: [u8; 32] = [5; 32];\n    let secret: [u8; 32] = [6; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // High volume: 500K total\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n    trade_amounts[1] = 150000;\n    trade_amounts[2] = 250000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        3,\n        trade_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_different_epochs_different_nullifiers() {\n    let wallet_pubkey: [u8; 32] = [7; 32];\n\n    let nullifier_epoch1 = compute_test_nullifier(wallet_pubkey, 1);\n    let nullifier_epoch2 = compute_test_nullifier(wallet_pubkey, 2);\n\n    // Critical security property\n    assert(nullifier_epoch1 != nullifier_epoch2);\n}\n\n// === Negative Tests ===\n\n#[test(should_fail)]\nfn test_below_threshold_volume_fails() {\n    let wallet_pubkey: [u8; 32] = [7; 32];\n    let secret: [u8; 32] = [8; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Only 30K volume (below 50K threshold)\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 10000;\n    trade_amounts[1] = 10000;\n    trade_amounts[2] = 10000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        3,\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_commitment_fails() {\n    let wallet_pubkey: [u8; 32] = [9; 32];\n    let secret: [u8; 32] = [10; 32];\n    let epoch: u64 = 1;\n\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n    let wrong_commitment: [u8; 32] = [0; 32];\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        wrong_commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_nullifier_fails() {\n    let wallet_pubkey: [u8; 32] = [11; 32];\n    let secret: [u8; 32] = [12; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let wrong_nullifier: [u8; 32] = [0; 32];\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        commitment,\n        wrong_nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_epoch_nullifier_fails() {\n    let wallet_pubkey: [u8; 32] = [13; 32];\n    let secret: [u8; 32] = [14; 32];\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, 1);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    // Use epoch 2 but nullifier computed with epoch 1\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        2,  // Different epoch\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_data_hash_fails() {\n    let wallet_pubkey: [u8; 32] = [15; 32];\n    let secret: [u8; 32] = [16; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // Actual trades\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n\n    // Hash from fake trades\n    let mut fake_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    fake_amounts[0] = 200000;\n    let wrong_data_hash = compute_trade_data_hash(fake_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        epoch,\n        wrong_data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_zero_trades_fails() {\n    let wallet_pubkey: [u8; 32] = [17; 32];\n    let secret: [u8; 32] = [18; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        0,  // Zero trades\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n// === Additional Edge Case Tests ===\n\n#[test]\nfn test_single_large_trade() {\n    let wallet_pubkey: [u8; 32] = [19; 32];\n    let secret: [u8; 32] = [20; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 1000000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_max_trades() {\n    let wallet_pubkey: [u8; 32] = [21; 32];\n    let secret: [u8; 32] = [22; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    // All 20 trades with 5K each = 100K total\n    let trade_amounts: [u64; MAX_TRADES] = [5000; MAX_TRADES];\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        20,\n        trade_amounts,\n        100000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_zero_threshold() {\n    let wallet_pubkey: [u8; 32] = [23; 32];\n    let secret: [u8; 32] = [24; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        0,  // Zero threshold\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_exceed_max_trades_fails() {\n    let wallet_pubkey: [u8; 32] = [25; 32];\n    let secret: [u8; 32] = [26; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let trade_amounts: [u64; MAX_TRADES] = [10000; MAX_TRADES];\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        21,  // Exceeds MAX_TRADES\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_large_volume_values() {\n    let wallet_pubkey: [u8; 32] = [27; 32];\n    let secret: [u8; 32] = [28; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 1000000000000;\n    trade_amounts[1] = 500000000000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        trade_amounts,\n        1000000000000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_secret_fails() {\n    let wallet_pubkey: [u8; 32] = [29; 32];\n    let secret: [u8; 32] = [30; 32];\n    let wrong_secret: [u8; 32] = [31; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        wrong_secret,\n        1,\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_wallet_fails() {\n    let wallet_pubkey: [u8; 32] = [32; 32];\n    let wrong_wallet: [u8; 32] = [33; 32];\n    let secret: [u8; 32] = [34; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wrong_wallet,\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_threshold_exact_match() {\n    let wallet_pubkey: [u8; 32] = [35; 32];\n    let secret: [u8; 32] = [36; 32];\n    let epoch: u64 = 1;\n\n    let commitment = compute_commitment(wallet_pubkey, secret);\n    let nullifier = compute_test_nullifier(wallet_pubkey, epoch);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 50000;\n    let data_hash = compute_trade_data_hash(trade_amounts);\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,  // Exact match\n        epoch,\n        data_hash,\n        commitment,\n        nullifier\n    );\n}\n","path":"/home/dewaxindo/Solana/vouch-protocol/circuits/whale_trading/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}