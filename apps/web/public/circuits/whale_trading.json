{
  "noir_version": "1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9",
  "hash": "10584224755354404093",
  "abi": {
    "parameters": [
      {
        "name": "wallet_pubkey",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "secret",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "trade_count",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "private"
      },
      {
        "name": "trade_amounts",
        "type": {
          "kind": "array",
          "length": 20,
          "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
        },
        "visibility": "private"
      },
      {
        "name": "min_volume",
        "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
        "visibility": "public"
      },
      {
        "name": "commitment",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "nullifier",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "14990209321349310352": { "error_kind": "string", "string": "attempt to add with overflow" }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pdbRjtowEAXQf8kzD56xx2PzK1WFAoRVpCigLFSqEP9em52b0oesttmnuSS5RyJxrNybY7e/ve368XR+b7Y/7s1+6oehf9sN50N77c9jOXp/bBr83F2nriuHmpfzpXVpp268NtvxNgyb5lc73J4XvV/a8Tmv7VTOuk3TjccyC3jqh66mx+Zv2y1XlVBWjnNd+Mt9EfRjWNP3Ef1S+v9+IrZ+4rymH+a+ylJflvvsKBvA7vUOfh3wbgZ8WgA++QeZk/VzWPMEssx9jd/rZ7eiT8RYQkSBVgnzIl4rsFMI7P0aQTlAUFl1H5LDSqLk1zwJyoSXiXLQJaFe9L3l/LmwuJ5/lh/toZ/+2QMbEtdsy70joeeLQsI2vc1gU2xGm2oz2cwfMzqb5kXzonnRvGheNC+aF82L5ql5ap6ap+apeWqemqfmqXlqXjIvmZfMS8VLdQabxasLm1JEUISEkOuKLSE7BEJgBI8QEAQhIihCQjCZnUMgBEbwCAFBECKCIiQEyASZIBNkgkyQCTJBJsgEmSAzZIbMkBkyQ2bIDJmr7GtICNmCdwhVlhr444Uo+wZCQBCEiKAICSFbCA6BECAHyAFygBwgB8gBcoAskAWyQBbIAlkgC2SBLJAFcoQcIUfI8Sk/6kYx9e1+6OyD53QbDy/fP9ffF5zBF9JlOh+6423q6j7xPFd2jj8=",
  "file_map": {
    "52": {
      "source": "// Vouch Protocol - Whale Trading Circuit\n// Proves: \"I control a wallet that traded >= min_volume in the period\"\n// Without revealing: which wallet, which trades, exact volume\n\nuse std::hash::blake2s;\n\n// Maximum number of trades to prove\nglobal MAX_TRADES: u32 = 20;\n\nfn main(\n    // Private inputs (hidden from verifier)\n    wallet_pubkey: [u8; 32],\n    secret: [u8; 32],\n    trade_count: u8,\n    trade_amounts: [u64; MAX_TRADES],\n\n    // Public inputs (visible to verifier)\n    min_volume: pub u64,\n    commitment: pub [u8; 32],\n    nullifier: pub [u8; 32]\n) {\n    // 1. Verify commitment = hash(wallet_pubkey || secret)\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let computed_commitment: [u8; 32] = blake2s(preimage);\n    assert(computed_commitment == commitment);\n\n    // 2. Verify trade count is valid\n    assert(trade_count >= 1);\n    assert(trade_count as u32 <= MAX_TRADES);\n\n    // 3. Sum trading volume\n    let mut total_volume: u64 = 0;\n    for i in 0..MAX_TRADES {\n        total_volume = total_volume + trade_amounts[i];\n    }\n\n    // 4. Verify total volume meets threshold\n    assert(total_volume >= min_volume);\n\n    // 5. Verify nullifier is derived correctly\n    // nullifier = hash(wallet_pubkey || domain_separator)\n    // Domain separator: \"vouch_whale\" padded to 32 bytes\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    // Domain separator: \"vouch_whale\" in ASCII (11 bytes, rest padded with zeros)\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let computed_nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Direct array comparison (more efficient than byte-by-byte)\n    assert(computed_nullifier == nullifier);\n}\n\n#[test]\nfn test_valid_whale_proof() {\n    let wallet_pubkey: [u8; 32] = [1; 32];\n    let secret: [u8; 32] = [2; 32];\n\n    // Compute commitment\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    // Compute nullifier\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Volume: 10K + 15K + 20K + 5K + 25K = 75K (meets 50K threshold)\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 10000;\n    trade_amounts[1] = 15000;\n    trade_amounts[2] = 20000;\n    trade_amounts[3] = 5000;\n    trade_amounts[4] = 25000;\n\n    main(\n        wallet_pubkey,\n        secret,\n        5,\n        trade_amounts,\n        50000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_high_volume_whale() {\n    let wallet_pubkey: [u8; 32] = [5; 32];\n    let secret: [u8; 32] = [6; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // High volume: 500K total (meets 100K threshold)\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n    trade_amounts[1] = 150000;\n    trade_amounts[2] = 250000;\n\n    main(\n        wallet_pubkey,\n        secret,\n        3,\n        trade_amounts,\n        100000,\n        commitment,\n        nullifier\n    );\n}\n\n// === Negative Tests ===\n\n#[test(should_fail)]\nfn test_below_threshold_volume_fails() {\n    let wallet_pubkey: [u8; 32] = [7; 32];\n    let secret: [u8; 32] = [8; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Only 30K volume (below 50K threshold) - should fail\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 10000;\n    trade_amounts[1] = 10000;\n    trade_amounts[2] = 10000;\n\n    main(\n        wallet_pubkey,\n        secret,\n        3,\n        trade_amounts,\n        50000,  // Threshold is 50K but volume is only 30K\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_commitment_fails() {\n    let wallet_pubkey: [u8; 32] = [9; 32];\n    let secret: [u8; 32] = [10; 32];\n\n    // Compute correct nullifier\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Use WRONG commitment\n    let wrong_commitment: [u8; 32] = [0; 32];\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        wrong_commitment,  // Wrong commitment - should fail\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_nullifier_fails() {\n    let wallet_pubkey: [u8; 32] = [11; 32];\n    let secret: [u8; 32] = [12; 32];\n\n    // Compute correct commitment\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    // Use WRONG nullifier\n    let wrong_nullifier: [u8; 32] = [0; 32];\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        commitment,\n        wrong_nullifier  // Wrong nullifier - should fail\n    );\n}\n\n#[test(should_fail)]\nfn test_zero_trades_fails() {\n    let wallet_pubkey: [u8; 32] = [13; 32];\n    let secret: [u8; 32] = [14; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n\n    // Zero trades - should fail (trade_count must be >= 1)\n    main(\n        wallet_pubkey,\n        secret,\n        0,  // Zero trades - should fail\n        trade_amounts,\n        50000,\n        commitment,\n        nullifier\n    );\n}\n\n// === Additional Edge Case Tests ===\n\n#[test]\nfn test_single_large_trade() {\n    let wallet_pubkey: [u8; 32] = [15; 32];\n    let secret: [u8; 32] = [16; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Single trade of 1M volume\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 1000000;\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        100000,  // 100K threshold\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_max_trades() {\n    let wallet_pubkey: [u8; 32] = [17; 32];\n    let secret: [u8; 32] = [18; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // All 20 trades with small amounts (5K each = 100K total)\n    let trade_amounts: [u64; MAX_TRADES] = [5000; MAX_TRADES];\n\n    main(\n        wallet_pubkey,\n        secret,\n        20,  // MAX_TRADES\n        trade_amounts,\n        100000,  // Exactly 100K\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_zero_threshold() {\n    let wallet_pubkey: [u8; 32] = [19; 32];\n    let secret: [u8; 32] = [20; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Zero volume with zero threshold should pass\n    let trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        0,  // Zero threshold\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_exceed_max_trades_fails() {\n    let wallet_pubkey: [u8; 32] = [21; 32];\n    let secret: [u8; 32] = [22; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let trade_amounts: [u64; MAX_TRADES] = [10000; MAX_TRADES];\n\n    // trade_count = 21 exceeds MAX_TRADES (20) - should fail\n    main(\n        wallet_pubkey,\n        secret,\n        21,  // Exceeds MAX_TRADES\n        trade_amounts,\n        50000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_large_volume_values() {\n    let wallet_pubkey: [u8; 32] = [23; 32];\n    let secret: [u8; 32] = [24; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Large trade values (billions in lamports)\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 1000000000000;  // 1 trillion\n    trade_amounts[1] = 500000000000;   // 500 billion\n\n    main(\n        wallet_pubkey,\n        secret,\n        2,\n        trade_amounts,\n        1000000000000,  // 1 trillion threshold\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_secret_fails() {\n    let wallet_pubkey: [u8; 32] = [25; 32];\n    let secret: [u8; 32] = [26; 32];\n    let wrong_secret: [u8; 32] = [27; 32];\n\n    // Compute commitment with CORRECT secret\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n\n    // Use WRONG secret - should fail\n    main(\n        wallet_pubkey,\n        wrong_secret,  // Wrong secret\n        1,\n        trade_amounts,\n        50000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test(should_fail)]\nfn test_wrong_wallet_fails() {\n    let wallet_pubkey: [u8; 32] = [28; 32];\n    let wrong_wallet: [u8; 32] = [29; 32];\n    let secret: [u8; 32] = [30; 32];\n\n    // Compute commitment with CORRECT wallet\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    // Compute nullifier with CORRECT wallet\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 100000;\n\n    // Use WRONG wallet - should fail\n    main(\n        wrong_wallet,  // Wrong wallet\n        secret,\n        1,\n        trade_amounts,\n        50000,\n        commitment,\n        nullifier\n    );\n}\n\n#[test]\nfn test_threshold_exact_match() {\n    let wallet_pubkey: [u8; 32] = [31; 32];\n    let secret: [u8; 32] = [32; 32];\n\n    let mut preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        preimage[i] = wallet_pubkey[i];\n        preimage[i + 32] = secret[i];\n    }\n    let commitment: [u8; 32] = blake2s(preimage);\n\n    let mut nullifier_preimage: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        nullifier_preimage[i] = wallet_pubkey[i];\n    }\n    let domain: [u8; 11] = [118, 111, 117, 99, 104, 95, 119, 104, 97, 108, 101];\n    for i in 0..11 {\n        nullifier_preimage[32 + i] = domain[i];\n    }\n    let nullifier: [u8; 32] = blake2s(nullifier_preimage);\n\n    // Exactly 50K volume (meets 50K threshold)\n    let mut trade_amounts: [u64; MAX_TRADES] = [0; MAX_TRADES];\n    trade_amounts[0] = 50000;\n\n    main(\n        wallet_pubkey,\n        secret,\n        1,\n        trade_amounts,\n        50000,  // Exact match\n        commitment,\n        nullifier\n    );\n}\n",
      "path": "/Users/dewaxindo/Documents/Work/vouch-protocol/circuits/whale_trading/src/main.nr"
    }
  },
  "expression_width": { "Bounded": { "width": 4 } }
}
